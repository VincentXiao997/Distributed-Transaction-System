# Distributed Transaction System

This is a distributed transaction system which supports read and write distributed objects while ensuring full ACI(D) properties. Durability (D) wasn't considered here since all objects are stored in memory and we mainly wanted to concentrate on the implement of the Transaction Protocol. 

## Usage

### Start servers

Each server must take two arguments. The first argument identifies the branch that the server must handle. The second argument is a configuration file. E.g.: ./server C config.txt.

### Start clients

A client takes two arguments – the first argument is a client id (unique for each client), and the second argument is the configuration file (same as above), which provides the required details for connecting to a server when processing a transaction. E.g., ./client asdf config.txt.

### Configuration

```sh
A A_IP_ADDRESS A_PORT
B B_IP_ADDRESS B_PORT
C C_IP_ADDRESS C_PORT
D D_IP_ADDRESS D_PORT
E E_IP_ADDRESS E_PORT
```

### Operations

This system supprts following operations:

- BEGIN: Start a transaction. All input before BEGIN will be ignored.
- COMMIT: Commit a transaction. If no balance is negation, all data will be stored into branchs, otherwise, aborted.
- ABORT: Abort a transaction. Rollback all changes. Input after ABORT will be ignored.
- DEPOSIT BRANCH_NAME.ACCOUNT_NAME AMOUNT: Deposit AMOUNT money in to account "ACCOUNT_NAME" in branch "BRANCH_NAME". If the branch doesn't have the account, create it.
- WITHDRAW BRANCH_NAME.ACCOUNT_NAME AMOUNT: Withdraw AMOUNT money from account "ACCOUNT_NAME" in branch "BRANCH_NAME". If the account doesn't exist, abort the transaction.
- BALABCE BRANCH_NAME.ACCOUNT_NAME: Show the balance of the account. If the account doesn't exist, abort the transaction.

## Implement

Coordinator works as a bridge between client side and server side, and this role will be assigned to first server in the cluster of servers. Both clients and servers that are not assigned as a coordinator are isolated, and they could only communicate with the coordinator. Once servers are started, each server will identify the coordinator by reading the first line of config.txt and try to establish connections between itself and the coordinator. When a client is started, it will automatically connect with the coordinator.


### Concurrency Control Approach

Transactions are executed in parallel, and we use strict two-phase locking to ensure the serializability. There are two types of lock: write lock and read lock, where write lock is exclusive and read lock is shared. Locks are required by Coordinator through AccountMessage, if locks can be granted, server replies to Coordinator with lock type via AccountMessage, otherwise it replies with None via AccountMessage.

### Abort and Roll Back

**General strategy**:
All results generated by uncommitted transactions are temporarily stored in Coordinator’s record. When a transaction is to be aborted, Coordinator first sends AbortedMessages to all servers that is engaged in this transaction to ask them to release correspond locks. Then it deletes the result in its own records specified by client’s name and transaction’s id, and reply “ABORTED” or “NOT FOUND, ABORTED”. 

Coordinator will also spontaneously abort a transaction if there’s no users’ input for 50 seconds. After it executes the last operation in a transaction, if it notices that the last operation is neither COMMIT nor ABORT, which means the transaction is still open, it starts to count the waiting time for this client. Once the waiting time exceeds 50 seconds, it automatically aborts the transaction and replies to client with ”ABORTED”.